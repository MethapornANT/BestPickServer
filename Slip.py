import mysql.connector
from datetime import datetime, timedelta
import requests
import os
import qrcode
from qrcode.constants import ERROR_CORRECT_H
import uuid
from flask import Flask, jsonify, request
import base64
import io
from promptpay import qrcode as promptpay_qrcode # ‡∏¢‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡πÑ‡∏ß‡πâ‡∏Ç‡πâ‡∏≤‡∏á‡∏ö‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô

app = Flask(__name__)

# --- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ---
DB_CONFIG = {
    'host': 'localhost',
    'user': 'root',     # ‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô MySQL ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    'password': '1234', # ‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô MySQL ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    'database': 'reviewapptest'      # ‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
}

# --- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ SlipOK API (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡πÉ‡∏ô Production ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô Environment Variables) ---
SLIP_OK_API_ENDPOINT = "https://api.slipok.com/api/line/apikey/49130"
SLIP_OK_API_KEY = "SLIPOKKBE52WN" 

# --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ---
def get_db_connection():
    try:
        conn = mysql.connector.connect(**DB_CONFIG)
        return conn
    except mysql.connector.Error as err:
        print(f"Error connecting to database: {err}")
        return None

# --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô DB Interactions ---

def find_order_by_id(order_id):
    conn = get_db_connection()
    if conn is None:
        return None
    cursor = conn.cursor(dictionary=True)
    try:
        # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏ö slip_transaction_id ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å query
        query = "SELECT id, user_id, amount, order_status, promptpay_qr_payload FROM orders WHERE id = %s"
        cursor.execute(query, (order_id,))
        order = cursor.fetchone()
        return order
    except mysql.connector.Error as err:
        print(f"Error finding order by ID: {err}")
        return None
    finally:
        cursor.close()
        conn.close()

def update_order_with_promptpay_payload(order_id, payload_to_store_in_db):
    conn = get_db_connection()
    if conn is None:
        return False
    cursor = conn.cursor()
    try:
        query = """
            UPDATE orders
            SET promptpay_qr_payload = %s, updated_at = NOW()
            WHERE id = %s
        """
        cursor.execute(query, (payload_to_store_in_db, order_id))
        conn.commit()
        print(f"‚úÖ Order ID: {order_id} updated with PromptPay payload '{payload_to_store_in_db}' in promptpay_qr_payload.")
        return True
    except mysql.connector.Error as err:
        print(f"Error updating order with PromptPay payload: {err}")
        conn.rollback()
        return False
    finally:
        cursor.close()
        conn.close()

def create_advertisement(order_data, package_duration_days):
    conn = get_db_connection()
    if conn is None:
        return None
    cursor = conn.cursor()
    try:
        now = datetime.now()
        expires_at = (now + timedelta(days=package_duration_days)).date()

        query = """
            INSERT INTO ads
            (user_id, order_id, title, content, status, created_at, expiration_date)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """
        default_title = f"Advertisement for Order {order_data['id']}"
        default_content = "This is a new advertisement activated by payment."

        cursor.execute(query, (
            order_data['user_id'],
            order_data['id'],
            default_title,
            default_content,
            'active',
            now,
            expires_at
        ))
        conn.commit()
        ad_id = cursor.lastrowid
        print(f"üöÄ Advertisement ID: {ad_id} created for Order ID: {order_data['id']}. Expires at: {expires_at.isoformat()}")
        return ad_id
    except mysql.connector.Error as err:
        print(f"Error creating advertisement: {err}")
        conn.rollback()
        return None
    finally:
        cursor.close()
        conn.close()

# --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á PromptPay QR Code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Order ---
def generate_promptpay_qr_for_order(order_id):
    order = find_order_by_id(order_id)
    if not order:
        return {"success": False, "message": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠"}

    amount = float(order["amount"])
    promptpay_id = "1103703685864" # PromptPay ID ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö SlipOK dashboard
    
    # Generate the ORIGINAL PromptPay payload (for QR Code image)
    original_scannable_payload = promptpay_qrcode.generate_payload(promptpay_id, amount)

    # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà order_id ‡∏ô‡∏≥‡∏´‡∏ô‡πâ‡∏≤ payload ‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏á‡∏ß‡∏•‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á uniqueness ‡∏ó‡∏µ‡πà‡∏ù‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ
    payload_to_store_in_db = original_scannable_payload

    if not update_order_with_promptpay_payload(order_id, payload_to_store_in_db):
        return {"success": False, "message": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• QR Code ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ"}
    
    # Note: We print the DB-stored payload here for logging
    # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Log
    print(f"‚úÖ Generated PromptPay payload (stored in DB): {payload_to_store_in_db}")
    
    # Use the ORIGINAL payload for QR code generation
    qr = qrcode.QRCode(
        version=1,
        error_correction=ERROR_CORRECT_H,
        box_size=10,
        border=4,
    )
    qr.add_data(original_scannable_payload) # Use original payload here
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")
    qr_path = f"qrcode_order_{order_id}.png"
    if hasattr(img, 'get_image'):
        img = img.get_image()
    img.save(qr_path)
    
    # Return the ORIGINAL payload to the client, as they will send this back for verification
    return {"success": True, "message": "‡∏™‡∏£‡πâ‡∏≤‡∏á QR Code ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", "qr_path": qr_path, "payload": original_scannable_payload}

# --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ï‡∏≤‡∏° SlipOK API Guide ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ) ---

def verify_payment_and_activate_ad(order_id, slip_image_path, payload_from_client): # Renamed payload to payload_from_client for clarity
    print(f"\n--- Processing payment for Order ID: {order_id} ---")
    print(f"Slip image path: {slip_image_path}")
    print(f"Payload (from client - original QR data): {payload_from_client}")

    order = find_order_by_id(order_id)
    if not order:
        print(f"‚ùå Error: Order ID {order_id} not found.")
        return {"success": False, "message": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠"}
    if order["order_status"] != 'pending':
        print(f"‚ùå Error: Order ID {order_id} is not pending. Current status: {order['order_status']}.")
        return {"success": False, "message": "‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ô‡∏µ‡πâ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"}
    
    try:
        if not os.path.exists(slip_image_path):
            print(f"‚ùå Error: Slip image file not found at '{slip_image_path}'")
            return {"success": False, "message": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ"}

        with open(slip_image_path, 'rb') as img_file:
            files = {'files': img_file}
            form_data_for_slipok = {
                'log': 'true',
                'amount': str(float(order["amount"])) # ‡πÅ‡∏õ‡∏•‡∏á amount ‡πÄ‡∏õ‡πá‡∏ô string ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö form-data
            }
            headers = {
                "x-authorization": SLIP_OK_API_KEY,
            }
            print(f"Sending request to SlipOK API: {SLIP_OK_API_ENDPOINT}")
            print(f"Headers sent: {headers}")
            print(f"Form Data sent to SlipOK: {form_data_for_slipok}")

            response = requests.post(SLIP_OK_API_ENDPOINT, files=files, data=form_data_for_slipok, headers=headers, timeout=30)
            response.raise_for_status() 

            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π Response ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            print(f"DEBUG: Full SlipOK response text: {response.text}")

            slip_ok_response_data = response.json()
            print(f"Received response from SlipOK: {slip_ok_response_data}")

            # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Error Code ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            if not slip_ok_response_data.get("success"):
                error_code = str(slip_ok_response_data.get("code")) # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô string ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö
                error_message = slip_ok_response_data.get("message", "Unknown error from SlipOK API")
                
                print(f"‚ùå Log: Error from SlipOK API (Code: {error_code}): {error_message}")

                if error_code == "1002": # "Authorization Header ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" 
                    return {"success": False, "message": f"‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: API Key ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï ({error_message})"}
                elif error_code == "1012": # "‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥ (Duplicate Slip)"
                    print(f"‚ö†Ô∏è Log: User attempted to use a duplicate slip for Order ID {order_id}. SlipOK reports: {error_message}")
                    return {"success": False, "message": f"‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏•‡∏¥‡∏õ ({error_message})"}
                elif error_code == "1013": # "‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏¢‡∏≠‡∏î‡∏™‡∏•‡∏¥‡∏õ"
                    print(f"‚ö†Ô∏è Log: Amount mismatch reported by SlipOK for Order ID {order_id}. SlipOK reports: {error_message}")
                    return {"success": False, "message": f"‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ({error_message})"}
                elif error_code == "1014": # "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡πâ‡∏≤‡∏ô" 
                    return {"success": False, "message": f"‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÉ‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô SlipOK ({error_message})"}
                elif error_code == "1006": # "‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"
                    return {"success": False, "message": f"‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ ({error_message})"}
                elif error_code == "1007": # "‡πÑ‡∏°‡πà‡∏°‡∏µ QR Code ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û"
                    return {"success": False, "message": f"‡πÑ‡∏°‡πà‡∏û‡∏ö QR Code ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ ‡∏´‡∏£‡∏∑‡∏≠ QR Code ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏ ({error_message})"}
                elif error_code == "1008": # "QR Code ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô"
                    return {"success": False, "message": f"QR Code ‡πÉ‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô ({error_message})"}
                elif error_code == "1010": # "‡∏™‡∏•‡∏¥‡∏õ‡∏°‡∏µ Delay"
                    return {"success": False, "message": f"‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏ã‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà ({error_message})"}
                
                # ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡πâ‡∏ô
                return {"success": False, "message": f"‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {error_message}"}

            # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ transRef ‡πÅ‡∏ó‡∏ô transactionId
            slipok_data = slip_ok_response_data.get("data")
            if not slipok_data:
                print(f"‚ùå Log: Unexpected response format from SlipOK API: 'data' field is missing or empty.")
                return {"success": False, "message": "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏•‡∏¥‡∏õ)"}

            # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ .get() ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏µ‡∏¢‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
            slip_transaction_id_from_api = slipok_data.get("transRef") # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å "transactionId" ‡πÄ‡∏õ‡πá‡∏ô "transRef"
            slip_amount = float(slipok_data.get("amount", 0.0)) # ‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô 0.0 ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ amount

            if not slip_transaction_id_from_api:
                print(f"‚ùå Log: Missing 'transRef' in SlipOK 'data' object.")
                return {"success": False, "message": "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏û‡∏ö Transaction ID)"}

    except requests.exceptions.Timeout:
        print(f"‚ùå Log: API Request Timeout: SlipOK API did not respond in time.")
        return {"success": False, "message": "‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ä‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"}
    except requests.exceptions.HTTPError as e:
        # ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î 4xx/5xx ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏î‡∏±‡∏Å‡∏î‡πâ‡∏ß‡∏¢ response.json().get("success") (‡πÄ‡∏ä‡πà‡∏ô ‡∏ñ‡πâ‡∏≤ API ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô HTML ‡πÅ‡∏ó‡∏ô JSON)
        print(f"‚ùå Log: Network or API HTTP Error (Unhandled by custom codes): {e}")
        try:
            # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏≠‡πà‡∏≤‡∏ô response body ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏î‡∏±‡∏Å
            error_details = response.json()
            print(f"    Error Details: {error_details}")
            return {"success": False, "message": f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ: {error_details.get('message', 'Unknown HTTP Error')}"}
        except Exception:
            return {"success": False, "message": f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ: {e}"}
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Log: Network Error (e.g., DNS, connection refused): {e}")
        return {"success": False, "message": f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ: {e}"}
    except ValueError:
        print(f"‚ùå Log: Error: Could not parse amount from SlipOK response.")
        return {"success": False, "message": "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"}
    except Exception as e:
        print(f"‚ùå Log: An unexpected error occurred during SlipOK call: {e}")
        return {"success": False, "message": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏†‡∏≤‡∏¢‡πÉ‡∏ô"}

    # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢ find_order_by_slip_id() ‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ
    # if find_order_by_slip_id(slip_transaction_id_from_api):
    #     print(f"‚ùå Security Alert: Slip Transaction ID '{slip_transaction_id_from_api}' has already been used (internal check)!")
    #     return {"success": False, "message": "‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß (‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡πÇ‡∏î‡∏¢‡∏£‡∏∞‡∏ö‡∏ö‡∏†‡∏≤‡∏¢‡πÉ‡∏ô)"}

    if abs(slip_amount - float(order["amount"])) > 0.01:
        print(f"‚ùå Log: Amount mismatch. Order: {order['amount']}, Slip: {slip_amount}")
        return {"success": False, "message": f"‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ {order['amount']:.2f} ‡∏ö‡∏≤‡∏ó ‡πÅ‡∏ï‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö {slip_amount:.2f} ‡∏ö‡∏≤‡∏ó)"}

    conn = get_db_connection()
    if conn is None:
        return {"success": False, "message": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£"}
    try:
        conn.start_transaction()
        cursor = conn.cursor()
        # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏ö slip_transaction_id ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å query UPDATE
        query = """
            UPDATE orders
            SET order_status = %s, slip_image = %s, updated_at = NOW()
            WHERE id = %s
        """
        # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏ö slip_transaction_id_from_api ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å parameters
        cursor.execute(query, ("paid", slip_image_path, order_id))
        conn.commit()
        print(f"‚úÖ Order ID: {order_id} updated to 'paid' with slip image.")

        package_duration_days = 30
        ad_id = create_advertisement(order, package_duration_days)
        if ad_id is None:
            raise Exception("Failed to create advertisement.")
        conn.commit()
        print(f"‚úÖ Transaction committed successfully for Order ID: {order_id}")
        return {"success": True, "message": "‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö", "ad_id": ad_id}
    except Exception as e:
        print(f"‚ùå Log: Transaction failed for Order ID: {order_id}. Rolling back changes. Error: {e}")
        conn.rollback()
        return {"success": False, "message": f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£: {e}"}
    finally:
        if conn and conn.is_connected():
            conn.close()

# --- ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ---
if __name__ == "__main__":
    conn_test = get_db_connection()
    if conn_test:
        print("Database connection successful!")
        conn_test.close()
    else:
        print("Failed to connect to the database. Please check DB_CONFIG.")
        exit()

@app.route('/api/generate-qrcode/<int:order_id>', methods=['GET'])
def api_generate_qrcode(order_id):
    result = generate_promptpay_qr_for_order(order_id)
    if not result['success']:
        return jsonify(result), 400
    with open(result['qr_path'], 'rb') as f:
        img_bytes = f.read()
        img_b64 = base64.b64encode(img_bytes).decode('utf-8')
    return jsonify({
        'success': True,
        'order_id': order_id,
        'qrcode_base64': img_b64,
        'promptpay_payload': result.get('payload')
    })

@app.route('/api/verify-slip/<int:order_id>', methods=['POST'])
def api_verify_slip(order_id):
    if 'slip_image' not in request.files:
        return jsonify({'success': False, 'message': '‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå slip_image'}), 400
    file = request.files['slip_image']
    if file.filename == '':
        return jsonify({'success': False, 'message': '‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå'}), 400
    if 'payload' not in request.form:
        return jsonify({'success': False, 'message': '‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ payload (QR Code)'}), 400
    payload = request.form['payload']
    
    Slip_dir = 'Slip'
    if not os.path.exists(Slip_dir):
        os.makedirs(Slip_dir)
    save_path = os.path.join(Slip_dir, file.filename)
    file.save(save_path)
    print(f"‚úÖ Slip image uploaded to {save_path}")
    print(f"‚úÖ Payload from client (QR Code data): {payload}")
    
    result = verify_payment_and_activate_ad(order_id, save_path, payload)
    return jsonify(result)

if __name__ == '__main__':
    if not os.path.exists('uploads'):
        os.makedirs('uploads')
    app.run(port=5000, debug=True)